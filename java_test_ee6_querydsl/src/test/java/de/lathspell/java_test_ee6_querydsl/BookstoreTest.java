package de.lathspell.java_test_ee6_querydsl;

import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.persistence.ColumnResult;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityResult;
import javax.persistence.FieldResult;
import javax.persistence.Persistence;
import javax.persistence.SqlResultSetMapping;

import org.eclipse.persistence.config.QueryHints;
import org.eclipse.persistence.config.ResultType;
import com.mysema.query.jpa.impl.JPADeleteClause;
import com.mysema.query.jpa.impl.JPAQuery;
import com.mysema.query.jpa.impl.JPAUpdateClause;
import com.mysema.query.jpa.JPASubQuery;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

import de.lathspell.java_test_ee6_querydsl.model.Author;
import de.lathspell.java_test_ee6_querydsl.model.Book;
import de.lathspell.java_test_ee6_querydsl.model.BookToBookstore;
import de.lathspell.java_test_ee6_querydsl.model.Bookstore;
import de.lathspell.java_test_ee6_querydsl.model.Language;
import de.lathspell.java_test_ee6_querydsl.model.QAuthor;
import de.lathspell.java_test_ee6_querydsl.model.QBook;
import static de.lathspell.java_test_ee6_querydsl.model.Book.Status.*;

public class BookstoreTest {

    private static final String PERSISTENCE_UNIT_NAME = "javaTestJpaPU";
    private static QAuthor AUTHOR = QAuthor.author;
    private static QBook BOOK = QBook.book;
    private EntityManager em;
    private Language langDe;
    private Language langEn;
    private Author authorTwain;
    private Author authorVerne;
    private Bookstore bookstoreBlack;

    @Before
    public void before() {
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
        assertNotNull(factory);
        em = factory.createEntityManager();
        assertNotNull(em);

        fixtures();
    }

    @After
    public void after() {
        assertFalse(em.getTransaction().isActive());
        em.close();
    }

    @Test
    public void testCreate() {
        assertNull(new JPAQuery(em).from(BOOK).where(BOOK.title.eq("Huckleberry Finn")).singleResult(BOOK));

        Book book3 = new Book();
        book3.setAuthorId(authorTwain);
        book3.setTitle("Huckleberry Finn");
        book3.setLanguageId(langDe);
        // book3.setStatus(); - Default via @PrePersist

        em.getTransaction().begin();
        assertNull(book3.getId());
        assertNull(book3.getStatus());

        // Persisting only tells JPA to treat the object as stored, it is not
        // necessarily INSERT'ed in the database.
        em.persist(book3);
        assertNull(book3.getId());
        assertEquals(IN_STOCK, book3.getStatus()); // is IN_STOCK due to @PrePersist!

        // Flushing the JPA cache will ensure that the INSERT is actually done.
        // Fields marked with @GeneratedValue like "id" are read with a SELECT.
        // Makes only sense inside transactions.
        em.flush();
        assertNotNull(book3.getId());
        assertEquals(IN_STOCK, book3.getStatus());

        // Only after a refresh(), values for @Column(insertable=false) attributes
        // which are generated by the database are loaded into the model object.
        em.refresh(book3);
        assertNotNull(book3.getId());
        assertEquals(IN_STOCK, book3.getStatus());

        em.getTransaction().commit();

        // verify
        Book book3b = new JPAQuery(em).from(BOOK).where(BOOK.title.eq("Huckleberry Finn")).singleResult(BOOK);
        assertTrue(book3b.getId() >= 1);
        assertEquals("Mark", book3b.getAuthorId().getFirstName());
        assertEquals("Huckleberry Finn", book3b.getTitle());
        assertEquals(langDe, book3b.getLanguageId());
        assertEquals(IN_STOCK, book3b.getStatus());
    }

    @Test
    public void testUpdate() {
        assertEquals(2, new JPAQuery(em).from(BOOK).where(BOOK.languageId.eq(langDe)).count());
        assertEquals(1, new JPAQuery(em).from(BOOK).where(BOOK.languageId.eq(langEn)).count());

        // single update
        Book book = new JPAQuery(em).from(BOOK).where(BOOK.title.eq("Tom Sawyer")).singleResult(BOOK);
        book.setLanguageId(langEn);
        em.persist(book);

        assertEquals(2, new JPAQuery(em).from(BOOK).where(BOOK.languageId.eq(langDe)).count());
        assertEquals(1, new JPAQuery(em).from(BOOK).where(BOOK.languageId.eq(langEn)).count());

        // mass update
        em.getTransaction().begin();
        new JPAUpdateClause(em, BOOK).set(BOOK.languageId, langEn).where(BOOK.languageId.eq(langDe)).execute();
        em.getTransaction().commit();

        assertEquals(0, new JPAQuery(em).from(BOOK).where(BOOK.languageId.eq(langDe)).count());
        assertEquals(3, new JPAQuery(em).from(BOOK).where(BOOK.languageId.eq(langEn)).count());
    }

    @Test
    public void testDelete() {
        Book book = new JPAQuery(em).from(BOOK).where(BOOK.title.eq("Tom Sawyer")).singleResult(BOOK);
        assertNotNull(book);

        // single removal
        assertEquals(1, new JPAQuery(em).from(BOOK).where(BOOK.title.eq("Tom Sawyer")).count());

        em.getTransaction().begin();
        em.remove(book); // strangely, has no effect outside transaction?!
        em.getTransaction().commit();

        assertEquals(0, new JPAQuery(em).from(BOOK).where(BOOK.title.eq("Tom Sawyer")).count());

        // mass removal
        assertEquals(1, new JPAQuery(em).from(BOOK).where(BOOK.languageId.ne(langDe)).count());

        em.getTransaction().begin();
        long affected = new JPADeleteClause(em, BOOK).where(BOOK.languageId.ne(langDe)).execute(); // needs transaction!
        em.getTransaction().commit();

        assertEquals(1, affected);
        assertEquals(0, new JPAQuery(em).from(BOOK).where(BOOK.languageId.ne(langDe)).count());
    }

    @Test
    public void testToJsqlString() {
        JPAQuery q = new JPAQuery(em)
                .from(BOOK)
                .leftJoin(BOOK.authorId, AUTHOR)
                .where(AUTHOR.firstName.eq("Mark"))
                .orderBy(BOOK.id.asc())
                .limit(2);

        String jsql = q.toString();

        assertEquals("select book\n"
                + "from Book book\n"
                + "  left join book.authorId as author\n"
                + "where author.firstName = ?1\n"
                + "order by book.id asc", jsql);
    }

    @Test
    public void testSelectNativeSQL() {
        // simple result
        assertEquals(new Long(5), (Long) em.createNativeQuery("SELECT count(*) + 2 FROM books").getSingleResult());

        // object result
        Book b = (Book) em.createNativeQuery("SELECT * FROM books b WHERE b.title = 'Tom Sawyer'", Book.class).getSingleResult();
        assertNotNull(b);
        assertEquals(langDe, b.getLanguageId());

        // arbitrary result (query hints are EclipseLink specific!)
        Map<String, Integer> m = (Map) em.createNativeQuery("SELECT 11 as foo, 22 as bar").setHint(QueryHints.RESULT_TYPE, ResultType.Map).getSingleResult();
        assertNotNull(m);
        assertEquals(new Long(11), m.get("foo"));
        assertEquals(new Long(22), m.get("bar"));

        // arbitrary result (What a great API, not even a map? :-/)
        List<Object[]> l = em.createNativeQuery("SELECT 11 as foo, 22 as bar").getResultList();
        assertNotNull(l);
        assertEquals(1, l.size());
        assertEquals(new Long(11), (Long) (l.get(0)[0]));
        assertEquals(new Long(22), (Long) (l.get(0)[1]));
    }

    @Test
    public void testSelectQueryDSL() {
        // Single result
        Author author = new JPAQuery(em).from(AUTHOR).where(AUTHOR.firstName.eq("Mark")).singleResult(AUTHOR);
        assertNotNull(author);

        // Multiple results
        List<Author> authors = new JPAQuery(em).from(AUTHOR).list(AUTHOR);
        assertEquals(2, authors.size());

        // Count
        long num = new JPAQuery(em).from(BOOK).where(BOOK.languageId.eq(langDe)).count();
        assertEquals(2, num);

        // Complex query with JOIN, WHERE, ORDER BY and LIMIT
        List<Book> books2 = new JPAQuery(em)
                .from(BOOK)
                .leftJoin(BOOK.authorId, AUTHOR)
                .where(AUTHOR.firstName.eq("Mark"))
                .where(BOOK.id.gt(0).and(BOOK.id.isNotNull()))
                .orderBy(BOOK.id.asc())
                .limit(2)
                .list(BOOK);
        assertEquals(2, books2.size());

        // Individual JOIN condition and custom table alias names
        // ("B" is the same as "BOOK")
        QBook B = new QBook("b");
        QAuthor A = new QAuthor("a");
        String jsql = new JPAQuery(em)
                .from(B)
                .leftJoin(A).on(B.authorId.eq(A))
                .where(A.firstName.isNotNull())
                .toString();
        assertEquals("select b\n"
                + "from Book b\n"
                + "  left join Author a on b.authorId = a\n"
                + "where a.firstName is not null", jsql);

        // Subqueries
        jsql = new JPAQuery(em)
                .from(BOOK)
                .where(BOOK.authorId.id.goe(
                new JPASubQuery().from(AUTHOR).where(AUTHOR.firstName.eq("Mark")).unique(AUTHOR.id.min()))).toString();
        assertEquals("select book\n"
                + "from Book book\n"
                + "where book.authorId.id >= (select min(author.id)\n"
                + "from Author author\n"
                + "where author.firstName = ?1)", jsql);
    }

    private void fixtures() {
        em.getTransaction().begin();
        em.createNativeQuery("DELETE FROM book_to_bookstore").executeUpdate();
        em.createNativeQuery("DELETE FROM bookstores").executeUpdate();
        em.createNativeQuery("DELETE FROM books").executeUpdate();
        em.createNativeQuery("DELETE FROM authors").executeUpdate();
        em.createNativeQuery("DELETE FROM languages").executeUpdate();

        langDe = new Language();
        langDe.setCode("de");
        langDe.setName("Deutsch");
        em.persist(langDe);

        langEn = new Language();
        langEn.setCode("en");
        langEn.setName("English");
        em.persist(langEn);

        authorTwain = new Author();
        authorTwain.setFirstName("Mark");
        authorTwain.setLastName("Twain");
        em.persist(authorTwain);

        authorVerne = new Author();
        authorVerne.setFirstName("Jules");
        authorVerne.setLastName("Verne");
        em.persist(authorVerne);

        Book book1 = new Book();
        book1.setAuthorId(authorTwain);
        book1.setLanguageId(langEn);
        book1.setStatus(IN_STOCK); // No default value!
        book1.setTitle("The Awful German Language");
        em.persist(book1);

        Book book2 = new Book();
        book2.setAuthorId(authorTwain);
        book2.setLanguageId(langDe);
        book2.setStatus(IN_STOCK);
        book2.setTitle("Tom Sawyer");
        em.persist(book2);

        Book book3 = new Book();
        book3.setAuthorId(authorVerne);
        book3.setLanguageId(langDe);
        book3.setStatus(IN_STOCK);
        book3.setTitle("20.000 Meilen unter dem Meer");
        em.persist(book3);

        bookstoreBlack = new Bookstore();
        bookstoreBlack.setName("MyBookstore");
        em.persist(bookstoreBlack);

        BookToBookstore b2b = new BookToBookstore();
        b2b.setBookId(book2);
        b2b.setBookstoreId(bookstoreBlack);
        b2b.setCreatedAt(new Date());
        em.persist(b2b);

        b2b = new BookToBookstore();
        b2b.setBookId(book3);
        b2b.setBookstoreId(bookstoreBlack);
        b2b.setCreatedAt(new Date());
        em.persist(b2b);

        em.getTransaction().commit();
    }
}
